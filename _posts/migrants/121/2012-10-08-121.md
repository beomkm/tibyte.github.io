---
layout: post
title: '4비트 그레이코드(gray code) 변환 회로'
date: 2012-10-08 19:59:01+0900
author: b.kim
tags:
  - 전기,전자
catetory: blogposts
permalink: '121'
---


  

그레이 코드(Gray Code)는 2진 비가중치 코드의 하나로,

연속된 수들의 코드가 한 비트씩만 차이가 나는 특징이 있다.

때문에 아날로그 신호와 같이 연속적인 신호가 입력될 때 그레이 코드를 사용하면 신뢰성이 높아진다.

  
  
* 4비트를 모두 사용한 이진코드와 그레이코드 비교

(이 글에서 언급한 '이진코드'는 이진법으로 나타낸 이진수를 의미합니다)  

![](https://raw.githubusercontent.com/tibyte/blog-res/master/legacy/121/2.png)

  

  

그레이코드를 보면 0과 1이 일정한 주기로 반복되는 규칙을 확인할 수 있다.

2^3자리에서는 이진코드와 동일하고,

2^2자리에서는 최상위비트가 0일때 이진코드와 동일, 최상위비트가 1일때 이진코드와 반대.

2^1자리와 2^0자리에서도 마찬가지로  상위비트에 따라 이진코드와 동일한지 반대인지가 결정된다.

  

위와 같이, 이진코드를 그레이코드로 변환할 때는 최상위비트는 그대로 두고

자신의 비트와 그의 상위비트를 XOR연산하면 된다.

  

블록도로 나타내면 다음과 같다.

![](https://raw.githubusercontent.com/tibyte/blog-res/master/legacy/121/0.png)

  

프로그램으로 작성한다면, 같은 원리로

`(x>>1)^x`

의 형식으로 작성할 수 있을 것이다. (^는 비트 XOR연산자)

  

  

  

  

  

반대로 그레이코드를 이진코드로 바꾸는 것을 생각해 보면,

이진코드의 각 자리를 DCBA라고 할 때 그레이코드는

D D⊕C C⊕B B⊕A 이다. (⊕ : XOR)

D⊕C를 다시 C로 되돌리기 위해서 D와 XOR연산을 하여 D⊕(D⊕C)꼴로 만든다.

XOR연산에서는 결합법칙이 성립하므로 (D⊕D)⊕C로 계산하면, 0⊕C가 되어 C라는 결과가 나온다.

다음 자리인 C⊕B를 B로 되돌리려면 위와 같은 방법으로 C와 XOR하면 된다.

  

이처럼 그레이코드를 이진코드로 변환하려면 이진->그레이 때와는 다르게

상위비트의 XOR연산 결과를 가지고 또 하위비트와 XOR시킨다.

알기 쉽게 블록도로 나타내면 아래 그림처럼 나온다.

  

![](https://raw.githubusercontent.com/tibyte/blog-res/master/legacy/121/1.jpeg)

  

  



  

  

  

  

  

  

  

  

  


