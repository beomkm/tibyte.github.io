---
layout: post
title: '[알고리즘 문제] 유일한 수 두개'
date: 2016-12-08 02:17:00+0900
author: b.kim
tags:
  - post
catetory: blogposts
permalink: '279'
---


**출처**

Koreatech Onlinejudge([링크](http://judge.koreatech.ac.kr/problem.php?id=1074))

  

  

 ** 문제이해**

-50000이상 50000이하 정수로 이루어진 배열이 입력된다. 두 개의 수를 제외한 나머지 수는 모두 2개씩 존재한다. 단 하나씩만 존재하는 두 수를 크기가 작은 것부터 출력하는 문제이다.

  

  
 ** 문제접근**

유일한 수를 찾는 문제에서는([링크](http://tibyte.kr/226)) 모든 배열원소들을 XOR연산으로 누적하여 쉽게 구할 수
있었다. 그러나 이 문제에서는 2개를 찾아야 하므로 단순히 XOR로는 구할 수 없다.

  

 **1\. 배열 이용**

입력되는 수의 범위가 -50000부터 50000까지 100001크기의 범위이므로 크기 100001짜리 배열을 만들고, 모든 인자를 0으로
초기화한 후, 입력배열을 순차탐색하면서 해당 입력값을 인덱스로 하는 배열위치에 1을 더한다. 이 과정이 끝났을 때 1이 기록되어 있는 위치를
출력하면 된다. 이 방법의 한계는 입력되는 수의 범위가 더 클 경우 적용할 수 없다는 것이다.

 **  
**

 **2\. std::map 이용**

입력되는 수를 std::find()로 찾아서 값이 있으면 std::erase()로 지우고 없으면 추가한다.

최종적으로 남은 요소를 출력하면 된다

std::map은 rbtree로 되어있기 때문에 각 연산이 O(logn)이며 입력의 수만큼 반복하게 되므로 복잡도는 O(nlogn)이 된다.

 **  
**

 **3\. 비트연산(XOR) 이용**

(참고 : <http://www.geeksforgeeks.org/find-two-non-repeating-elements-in-an-
array-of-repeating-elements/>)

XOR연산으로도 이 문제를 풀 수 있다. 우선 모든 수를 XOR연산으로 누적하면 하나의 수가 나오는데, 이것은 답으로 출력해야 할 두 수의
XOR연산결과이다. 이 결과에서 rightmost set bit(낮은 비트부터 봤을 때 1이 처음으로 나타나는 위치)을 찾는다.

  

예를 들어 XOR결과가 이진수로 1101000라고 하자. rightmost set bit을 제외한 나머지 비트들을 0으로 하면
0001000이 된다. 이것은 모든 입력값들 중에서 해당 위치에 1이 쓰여진 원소가 홀수 개라는 뜻이 된다. 즉, 구하고자 하는 답 중에서
하나는 해당 위치에 1이 쓰여진 원소들 중에서 나오고, 다른 하나는 해당 위치에 0이 쓰여진 원소들 중에서 나온다는 것이다.

  

이제 다시 모든 원소들을 위에서 구한 XOR값(위 예시에서는 0001000)과 비트 AND 연산을 하면서, 결과가 1인 경우와, 결과가 0인
경우로 나누어 각각 XOR연산으로 누적한다.

 for(int i=0; i<N; ++i) {

if(arr[i]&det) {

xora ^= arr[i];

}

else {

xorb ^= arr[i];

}

}  
  
---  
  
문제의 조건에 따라, 구한 두 값을 크기순서로 출력하면 된다.

  
  

**구현**

이 문제에서 필요한 rightmost set bit의 형태는 위치값이 아니라, 해당 비트만 1로 세팅된 수이기 때문에 아래와 같은 간단한
연산으로 구할 수 있다.  (1101000을 예시로 하여 직접 계산해 보면 이해할 수 있다.)

num&(~num+1)

  

이 연산을 잘 보면, 2의보수를 구하고 있는 형태이기 때문에

num&-num 으로도 쓸 수 있다.

  

  
 ** 코드**  
https://github.com/tibyte/algorithm-problems/blob/master/koreatech/1074/1074.c


